<!DOCTYPE html>

<link rel="stylesheet" href="style.css">

<html>
  <title>Lua-preemption</title>
  <body><p><a href='./blog.html'>Back</a></p>
<p><span class='brightwhite'>Pre-emptive Multitasking in Lua, without the debug library</span><br>&nbsp;&nbsp;One of the more notable features I added to <a href='https://github.com/ocawesome101/oc-cynosure'>the original Cynosure kernel</a> was pre-emptive multitasking.&nbsp;&nbsp;When the full <span class='brightwhite'>debug</span> API is available, such as under <a href='https://computercraft.cc'>ComputerCraft</a>, this is a fairly simple thing to do.&nbsp;&nbsp;However, OpenComputers only provides a very restricted version of the <span class='brightwhite'>debug</span> API, since its sandbox is written in Lua and as such could easily be broken if it did not wrap said API.<br><br>&nbsp;&nbsp;All this to say, the <span class='brightwhite'>debug.sethook</span> function, necessary for pre-emption, is not present in OpenComputers.&nbsp;&nbsp;This means that I needed to find another way to do pre-emption.&nbsp;&nbsp;My solution was to wrap the <span class='brightwhite'>load</span> function.<br><br>&nbsp;&nbsp;After talking it over with some people on Discord, I added an initial implementation of this feature in commit <a href='https://github.com/Ocawesome101/oc-cynosure/commit/e8e2c0c3fc219c6ba4cc792155c04f9083101353'>e8e2c0c</a>.&nbsp;&nbsp;The version in that commit was quite primitive and did not respect code contained in strings.&nbsp;&nbsp;For programs that write to EEPROMs, for example, this could break things significantly.&nbsp;&nbsp;My initial implementation also just yielded every time an if, while, or for statement was detected - which, as you might imagine, was quite slow in OpenComputers.<br><br>&nbsp;&nbsp;My solution to the last problem was an <span class='brightwhite'>__internal_yield</span> function, which would check the last time the current process yielded and decide whether to actually yield based on that.&nbsp;&nbsp;(<a href='https://github.com/Ocawesome101/oc-cynosure/commit/cba6d42ca3712888fcd009d9972d7eb222a90bfe'>cba6d42</a>)<br><br>&nbsp;&nbsp;I quite significantly rewrote the feature in <a href='https://github.com/Ocawesome101/oc-cynosure/commit/b671504980269615e9f28ecf2730b2b800c00fd5'>b671504</a> to avoid processing code inside strings, with patch-ups in <a href='https://github.com/Ocawesome101/oc-cynosure/commit/89e90a16a0397ac5ed4a1727c2dc986a9d7ffd31'>89e90a1</a> and <a href='https://github.com/Ocawesome101/oc-cynosure/commit/aeecc1fe45fb691d936b2fc5201a4eaede3b45c4'>aeecc1f</a>, by which point it was much closer to actually usable.&nbsp;&nbsp;The last step was to make the <span class='brightwhite'>__internal_yield</span> function not eat signals, which I did in <a href='https://github.com/Ocawesome101/oc-cynosure/commit/726a19b2'>726a19b2</a>.&nbsp;&nbsp;While writing this article, I came across one final issue, which is fixed by <a href='https://github.com/Ocawesome101/oc-cynosure/commit/4ab303d96f7e723124ed7ddf46daec829158b064'>4ab303d</a>.<br><br>&nbsp;&nbsp;Now, how does this feature work?</p>
<p><span class='brightwhite'>How It Works</span><br>&nbsp;&nbsp;You may wish to follow along with the relevant source code, which is <a href='https://github.com/ocawesome101/oc-cynosure/blob/dev/base/load.lua'>here</a>.<br><br>&nbsp;&nbsp;At the beginning of the file, there is a table of patterns.&nbsp;&nbsp;These patterns dictate when to insert calls to the <span class='brightwhite'>__internal_yield</span> function.<br><br>&nbsp;&nbsp;Then, there is the <span class='brightwhite'>process_section</span> function, which iterates over that table and calls <span class='brightwhite'>string.gsub</span> with whatever is contained in each item of that table, plus the provided section of code.&nbsp;&nbsp;This works remarkably well.<br><br>&nbsp;&nbsp;The <span class='brightwhite'>process</span> function takes a chunk of code.&nbsp;&nbsp;It iterates over this code, finding any quotes that may be present.&nbsp;&nbsp;If it finds a quote, then it will process all code up to that quote with a call to itself, and set its internal state to reflect that it is now inside a string;&nbsp;&nbsp;if it is already inside a string, then it will update the internal state accordingly.&nbsp;&nbsp;If it does not find a quote, it will check for a multiline declaration (two <span class='brightwhite'>[</span> characters, with any number of <span class='brightwhite'>=</span>s between them).&nbsp;&nbsp;It will call <span class='brightwhite'>process_section</span> on the section of code leading up to this declaration, and then skip the multiline section.&nbsp;&nbsp;If the *brightwhite(process) function does not find either of these, it will simply concatenate the result of the <span class='brightwhite'>process_section</span> function and return.<br><br>&nbsp;&nbsp;Let's move on to the <span class='brightwhite'>load</span> wrapper function.&nbsp;&nbsp;This takes all the arguments that the standard Lua <span class='brightwhite'>load</span> does.&nbsp;&nbsp;Once it has obtained the string it is to load, however, things get fancier.<br><br>&nbsp;&nbsp;The first thing it does is call the <span class='brightwhite'>process</span> function on the chunk.&nbsp;&nbsp;It then loads the chunk and, if that fails, returns <span class='magenta'>nil</span> and an error message.&nbsp;&nbsp;However, if loading the chunk does not fail, then <span class='brightwhite'>load</span> returns another wrapper function.&nbsp;&nbsp;This wrapper saves the last yield time, and any previous instance of <span class='brightwhite'>__internal_yield</span> or <span class='brightwhite'>coroutine.yield</span> that may have been present in the provided environment.&nbsp;&nbsp;It then overrides them as follows:<br>&nbsp;&nbsp;&nbsp;&nbsp;- <span class='brightwhite'>__internal_yield</span>: if it's been more than the maximum time since the program last yielded, then yield.&nbsp;&nbsp;If the yield returns a signal, then save that to the local signal queue <span class='brightwhite'>ysq</span>.<br>&nbsp;&nbsp;&nbsp;&nbsp;- <span class='brightwhite'>coroutine.yield</span>: if there is a signal available in the locla signal queue, then return it; otherwise, update the last yield time and yield, passing through any arguments it may be passed.<br><br>&nbsp;&nbsp;After this is done, the original function (returned by the standard <span class='brightwhite'>load</span>) is called, the values of <span class='brightwhite'>__internal_yield</span> and <span class='brightwhite'>coroutine.yield</span> restored, and the results of the function call returned.</p>
<p><span class='brightwhite'>Conclusion</span><br>&nbsp;&nbsp;I hope you've learned something from this article.&nbsp;&nbsp;If you have any questions, message me at <span class='brightwhite'>Ocawesome101#5343</span> on Discord.&nbsp;&nbsp;I'm also accessible through <span class='brightwhite'>#oc</span> on <a href='https://irc.esper.net'>irc.esper.net</a> most of the time.</p>
  </body>
</html>
